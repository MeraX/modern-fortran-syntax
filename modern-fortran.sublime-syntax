%YAML 1.2
---
name: BeautifulFortran
file_extensions: [F90,F08,F18,f90,f08,f18]
scope: source.fortran

variables:
  intrinsicType: '(real|integer|complex|character|logical|byte|double precision|double complex)'
  intrinsicAttribute: '(allocatable|asynchronous|automatic|bind|codimension|contiguous|dimension|external|intent|intrinsic|optional|parameter|pointer|private|protected|public|save|static|target|value|volatile|deferred|pass|nopass|overridable|non_overridable)'
  intrinsicFunction: '(abs|achar|acos|acosh|adjustl|adjustr|aimag|aint|all|allocated|anint|any|asin|asinh|associated|atan|atan2|atanh|atomic_add|atomic_and|atomic_cas|atomic_define|atomic_fetch_add|atomic_fetch_and|atomic_fetch_or|atomic_fetch_xor|atomic_or|atomic_ref|atomic_xor|bessel_j0|bessel_j1|bessel_jn|bessel_y0|bessel_y1|bessel_yn|bge|bgt|bit_size|ble|bit|btest|c_associated|c_funloc|c_f_pointer|c_f_procpointer|c_loc|c_sizeof|ceiling|char|cmplx|co_broadcast|co_max|co_min|co_reduce|co_sum|coshape|command_argument_count|compiler_options|compiler_version|conjg|cos|cosh|count|cpu_time|cshift|date_and_time|dble|digits|dim|dot_product|dprod|dshiftl|dshiftr|eoshift|epsilon|erf|erfc|erfc_scaled|event_query|execute_command_line|exp|exponent|extends_type_of|float|floor|fraction|gamma|get_command|get_command_argument|get_environment_variable|huge|hypot|iachar|iall|iand|iany|ibclr|ibits|ibset|ichar|ieor|image_index|index|int|ior|iparity|is_iostat_end|is_iostat_eor|ishft|isfhtc|kind|lbound|lcobound|leadz|len|len_trim|lge|lgt|lle|llt|log|log10|log_gamma|logical|maskl|maskr|matmul|max|maxexponent|maxloc|maxval|merge|merge_bits|min|minexponent|minloc|minval|mod|module|move_alloc|mvbits|nearest|new\_line|nint|not|norm2|null|num_images|pack|parity|popcnt|poppar|precision|present|product|radix|random_number|random_seed|range|rank|real|repeat|reshape|rrspacing|same_type_as|scale|scan|selected_char_kind|selected_int_kind|selected_real_kind|set_exponent|shape|shifta|shiftl|shiftr|sign|sin|sinh|size|sngl|spacing|spread|sqrt|storage_size|sum|system_clock|tan|tanh|this_image|tiny|trailz|transfer|transpose|trim|ubound|ucobound|unpack|verify)'
  intrinsicSubroutine: '(nullify|allocate|deallocate)'
  intrinsicIO: '(print|write|read|inquire|open|close|rewind|backspace|endfile|flush|namelist)'
  intrinsicIOArguments: (unit|newunit|iunit|eunit|format|advance|asynchronous|blank|decimal|id|pad|pos|round|size|iostat|err|end|eor|iomsg|io-list|form|nml-group|nml|rec|delim|sign|name|label|msg-var|i-var|slist|access|action|associatevariable|blocksize|buffercount|buffered|carriagecontrol|convert|decimal|defaultfile|dispose|encoding|file|iofocus|maxrec|mode|noshared|organization|readonly|recordsize|recordtype|share|status|title|type|useropen|sz|slist|def)

  firstOnLine: '^\s*'
  parenthesisStart: '\(\s*'
  parenthesisEnd: '\s*\)'
  variableMatch: '[A-Za-z_][A-Za-z_0-9]*'
  ompDirectives: '(end|parallel|do|simd|single|target|update|workshare|declare|sections|distribute|teams|task|taskyield|master|critical|barrier|taskwait|taskgroup|atomic|flush|ordered|cancel|cancellation point|reduction)'
  ompIntrinsics: (omp_set_num_threads|omp_get_num_threads|omp_get_max_threads|omp_get_thread_num|omp_get_num_procs|omp_in_parallel|omp_set_dynamic|omp_get_dynamic|omp_get_cancellation|omp_set_nested|omp_get_nested|omp_set_schedule|omp_get_schedule|omp_get_thread_limit|omp_set_max_active_levels|omp_get_max_active_levels|omp_get_level|omp_get_ancestor_thread_num|omp_get_team_size|omp_get_active_level|omp_in_final|omp_get_proc_bind|omp_set_default_device|omp_get_default_device|omp_get_num_devices|omp_get_num_teams|omp_get_team_num|omp_is_initial_device|omp_init_lock|omp_init_nest_lock|omp_destroy_lock|omp_destroy_nest_lock|omp_set_lock|omp_set_nest_lock|omp_unset_lock|omp_unset_nest_lock|omp_test_lock|omp_test_nest_lock|omp_get_wtime|omp_get_wtick)
  ompClauses: (default|shared|private|firstprivate|lastprivate|linear|reduction|copyin|copyprivate|map|tofrom|safelen|collapse|simdlen|aligned|uniform|Inbrach|notinbranch)
  fppCommands: (define|undef|ifdef|ifndef|if|elif|else|endif|include|error|warning|line-number|line)

contexts:
  main:
    - include: preprocessing
    - include: comments 
    - include: types
    - include: attribute
    - include: operators
    - include: control
    - include: strings
    - include: continuation
    - include: procedures
    - include: modules
    - include: interfaces 
    - include: class-definitions
    - include: coarray
    - include: separators
    - include: numbers
    - include: constants
    - include: program
    - include: class-accessing
    - include: io
    - include: function-call
    - include: match-variable
    - include: omp

  comments:
    - match: '!(?![$])'
      scope: punctuation.definition.comment
      set:
      - meta_scope: comment.line
      - match: \n 
        pop: true

  types:
    - include: comments
    - include: strings
    - match: '(?i)\b{{intrinsicType}}\b(?=.*(function))' # type of return value in function 
      scope: storage.type.intrinsic
    - match: '(?i){{firstOnLine}}\b{{intrinsicType}}\b(?=.*::)' # type declaration
      scope: storage.type.intrinsic
      push: declaration
    - match: '(?i){{firstOnLine}}(type|class){{parenthesisStart}}\s*(\w*){{parenthesisEnd}}'
      captures:
        1: storage.type.class
        2: entity.name.class
      push: declaration

  attribute:
    - match: '(?i)\b{{intrinsicAttribute}}\b'
      scope: storage.modifier

  operators:
    - match: (==|/=|>=|<=|<|>)
      scope: keyword.operator.logical
    - match: (?i)(\.and\.|\.or\.|\.ne\.|\.lt\.|\.le\.|\.gt\.|\.ge\.|\.eq\.|\.not\.)
      scope: keyword.operator.word
    - match: (=>)
      scope: keyword.operator
    - match: (?i)(?<=d|e)(\-|\+)(?=\d) # - and + is not arithmetic 
                                       # in scientific notation (1.0d-2)
      scope: constant.numeric
    - match: (\*|\+|-|\/|=)
      scope: keyword.operator.arithmetic

  separators:
    - match: (::)
      scope: punctuation.separator
    - match: (:)
      scope: punctuation.separator
    - match: ','
      scope: punctuation.separator
    - match: '\%'
      scope: punctuation.accessor
    - match: '\;'
      scope: punctuation.terminator

  control:
    - include: comments
    - match: (?i)\b(end)\b
      scope: keyword.control
    # if ()
    - match: '(?i)\b(if)\b\s*{{parenthesisStart}}'
      captures:
        1: keyword.control
    # then
    - match: '(?i)\b(then)\b'
      scope: keyword.control
    # elseif ()
    - match: '(?i)\b(else)\s*(if)\b'
      captures:
        1: keyword.control
        2: keyword.control
    # else
    - match: '(?i)\b(else)\b'
      scope: keyword.control
    # endif
    - match: '(?i)\b(endif)\b'
      captures:
        1: keyword.control
    - match: '(?i)(?<=end)\s*(if)\b'
      scope: keyword.control
    # do 
    - match: '(?i)\b(do)\b'
      captures:
        1: keyword.control
    - match: '(?i)(?<=do)\s*(while)\b'
      scope: keyword.control
    # enddo
    - match: '(?i)(enddo)\b'
      captures:
        1: keyword.control
    - match: (?i)\b(select|case|default)\b
      scope: keyword.control
    - match: (?i)\b(exit|cycle|return)\b 
      scope: keyword.control
    # do concurrent 
    - match: (?i)(?<=do)\s+(concurrent)\b 
      scope: keyword.control
    - match: (?i)\b(concurrent|local|shared|local_init|default)\b 
      scope: keyword.control
    # named do & if statements
    - match: (?i)(\w+)\:\s*(?=do|if)
      scope: entity.name.label
    - match: (?i)(?<=then|else|if|do)\s+(\w+)\s*\n
      scope: entity.name.label

  newline-pop:
    - match: '\n'
      pop: true     

  declaration:
    - include: attribute
    - include: operators
    - include: separators
    - include: newline-pop
    - include: comments
    - include: strings
    - include: numbers
    - match: '(?i)\b(in|out|inout)\b' 
      scope: keyword.other 
    - include: class-accessing
    - include: match-variable

  continuation:
    - match: "&"
      scope: punctuation.separator.continuation

  strings:
    - match: "//"
      scope: keyword.operator.arithmetic
    - match: "'"
      push: string.single 
    - match: '"'
      push: string.double

  string.single:
    - meta_scope: string.quoted.single
    - include: string.continuation
    - include: newline-pop
    - match: "'"
      pop: true

  string.double:
    - meta_scope: string.quoted.single
    - include: string.continuation
    - include: newline-pop 
    - match: '"'
      pop: true

  string.continuation:
    - match: "&"
      scope: punctuation.separator.continuation
      push: 
        # locate continuation on next line and pop
        - match: "&" 
          scope: punctuation.separator.continuation 
          pop: true 

  procedures:
    - match: (?i)\b({{intrinsicFunction}})\b\s*(?=\()
      captures: 
        1: variable.function

    - match: (?i)\b({{intrinsicSubroutine}})\b\s*(?=\()
      captures:
        1: variable.function

    - match: (?i)\s*(result)\s*\( 
      captures: 
        1: keyword.control

    - match: (?i)\b(pure)\b
      scope: storage.modifier

    - match: (?i)(implicit none)
      scope: keyword.control

    - match: '(?i)\b(module)\b\s+(?=function|subroutine|procedure)'
      scope: storage.modifier

    - match: (?i)\b(function|subroutine)\b 
      scope: keyword.declaration.function

    - match: (?i)(?<=\bfunction|subroutine\b)\s+(\w+)
      captures: 
        1: entity.name.function 

    - match: '(?i)\b(call)\b'
      captures:
        1: keyword.control 

  io: 
    - match: '(?i)\b({{intrinsicIO}})\b'
      captures:
        1: variable.function
    - match: '(?i)\b({{intrinsicIOArguments}})\b'
      captures: 
        1: variable.language

  modules:
    - match: (?i)\b(module)\b\s*(\w*)$
      captures: 
        1: keyword.declaration.interface
        2: entity.name.interface
    - match: (?i)\b(submodule)\b\s*\((\w*)\)\s*(\w*)
      captures:
        1: keyword.declaration.interface
        2: entity.name.interface
        3: entity.name.interface
    - match: (?i)\b(submodule)\b\s*(\w*)
      captures:
        1: keyword.declaration.interface
        2: entity.name.interface
    - match: (?i)\b(use)\b
      scope: keyword.control
    - match: (?i)(?<=\buse\b)\s*(\w*)
      scope: entity.name.interface
    - match: (?i)\b(only)\b\s*(\:)
      captures:
        1: keyword.control
        2: punctuation.separator

  class-definitions:
    - match: ^(?i)(?<!\bend\b)\s+\b(type)\b(?!\s*\() # not the end of type; not variable specification; must be beginning of declaration
      scope: storage.type.class # should this be keyword.declaration.class??
      push: class-name
    - match: (?i)(procedure|generic)
      scope: keyword.declaration.function
    - match: (?i)(contains)
      scope: keyword.declaration.interface
    - match: '(?i)(?<=end)\s+(type)\s+(\w*)'
      captures:
        1: storage.type.class
        2: entity.name.class

  class-name:
    - include: newline-pop
    - include: separators
    - match: (?i)\b(extends)\b{{parenthesisStart}}(\w*){{parenthesisEnd}}
      captures:
        1: keyword.operator
        2: entity.other.inherited-class
    - match: (?i)\b(abstract)\b
      scope: storage.modifier
    - match: (?<=::)\s*(\w*)
      scope: entity.name.class
    - match: (?i)(?<=type)\s+(\w*) # simple type definition (type myType)
      scope: entity.name.class

  numbers:
    - match: '(\d+)'
      scope: constant.numeric
    - match: '(?i)(?<=\d)(d|e)'
      scope: constant.numeric
    - match: '(?<=\d)(\.)'
      scope: constant.numeric

  constants:
    - match: (?i)(\.true\.|\.false\.)
      scope: constant.language

  class-accessing:
    - include: comments 
    - match: '(\w+)\s*(?=\%|\[.*\]\(.*\)\%|\(.*\)\%|\[.*\]\%)'
      scope: storage.type.class
      #scope: variable.other (alternative scope)

  function-call:
    - match: '(\w*)\s*(?=\()'
      captures:
        1: variable.function

  interfaces:
    - match: (?i)(abstract)\s*(?=interface)
      scope: storage.modifier
    - match: (?i)(interface)
      scope: keyword.declaration.interface
    - match: '(?i)(?<=interface)\s*(\w*)'
      scope: entity.name.interface
    - match: (?i)(include)
      scope: keyword.control

  omp:
    - match: '{{firstOnLine}}(?i)(\!\$omp)'
      scope: support.function
      push: omp-line 
    - match: '{{firstOnLine}}(\!\$)'
      scope: support.function
      push: omp-line 

  omp-line:
    - include: omp-continuation
    - include: omp-directives
    - include: omp-intrinsic
    - include: omp-clauses
    - include: separators
    - match: (?i)(schedule)
      scope: support.function
      push: omp-schedule
    - include: match-variable
    - match: '\n'
      pop: true

  omp-directives:
    - match: ({{ompDirectives}})
      scope: support.function

  omp-intrinsic:
    - match: ({{ompIntrinsics}})
      scope: support.function

  omp-clauses:
    - include: omp-continuation
    - match: ({{ompClauses}})
      scope: support.constant

  omp-schedule:
    - include: omp-continuation
    - match: (?i)(static|dynamic|guided|auto)
      scope: support.constant
    - match: '{{parenthesisEnd}}'
      pop: true


  omp-continuation:
    - match: "&" 
      push:
        - match: '{{firstOnLine}}(?i)(\!\$omp)'
          scope: support.function
          pop: true

  match-variable:
    - match: ({{variableMatch}})
      scope: variable.other

  preprocessing:
    - match: '{{firstOnLine}}(\#)'
      scope: support.function
    - match: '(?i)(?<=\#)({{fppCommands}})'
      scope: support.function
    
  program:
    - match: (?i)\b(program)\b 
      scope: keyword.declaration.program.fortran 
    - match: '(?i)(?<=program)\s+(\w*)'
      scope: entity.name

  coarray:
    - match: (?i)\b(sync)\s+(all|images|memory)\b 
      captures: 
        1: keyword.control
        2: keyword.control
    - match: (?i)\b(lock|unlock)\b 
      scope: keyword.control
    - match: (?i)(event)\s+(post|wait)\s*(?=\()
      captures:
        1: keyword.control
        2: keyword.control 

