%YAML 1.2
---
name: BeautifulFortran
file_extensions: [F90,F08,F18,f90,f08,f18]
scope: source.fortran

variables:
  intrinsicType: '(real|integer|complex|character|logical|byte|double precision|double complex)'
  intrinsicAttribute: '(allocatable|asynchronous|automatic|bind|codimension|contiguous|dimension|
                        external|intent|intrinsic|optional|parameter|pointer|private|protected|
                        public|save|static|target|value|volatile)'
  intrinsicFunction: (abs|achar|acos|acosh|adjustl|adjustr|aimag|aint|all|allocated|anint|any|asin|asinh|associated|atan|atan2|atanh|atomic_add|atomic_and|atomic_cas|atomic_define|atomic_fetch_add|atomic_fetch_and|atomic_fetch_or|atomic_fetch_xor|atomic_or|atomic_ref|atomic_xor|bessel_j0|bessel_j1|bessel_jn|bessel_y0|bessel_y1|bessel_yn|bge|bgt|bit_size|ble|bit|btest|c_associated|c_funloc|c_f_pointer|c_f_procpointer|c_loc|c_sizeof|ceiling|char|cmplx|co_broadcast|co_max|co_min|co_reduce|co_sum|command_argument_count|compiler_options|compiler_version|conjg|cos|cosh|count|cpu_time|cshift|date_and_time|dble|digits|dim|dot_product|dprod|dshiftl|dshiftr|eoshift|epsilon|erf|erfc|erfc_scaled|event_query|execute_command_line|exp|exponent|extends_type_of|float|floor|fraction|gamma|get_command|get_command_argument|get_environment_variable|huge|hypot|iachar|iall|iand|iany|ibclr|ibits|ibset|ichar|ieor|image_index|index|int|ior|iparity|is_iostat_end|is_iostat_eor|ishft|isfhtc|kind|lbound|lcobound|leadz|len|len_trim|lge|lgt|lle|llt|log|log10|log_gamma|logical|maskl|maskr|matmul|max|maxexponent|maxloc|maxval|merge|merge_bits|min|minexponent|minloc|minval|mod|module|move_alloc|mvbits|nearest|new\_line|nint|not|norm2|null|num_images|pack|parity|popcnt|poppar|precision|present|product|radix|random_number|random_seed|range|rank|real|repeat|reshape|rrspacing|same_type_as|scale|scan|selected_char_kind|selected_int_kind|selected_real_kind|set_exponent|shape|shifta|shiftl|shiftr|sign|sin|sinh|size|sngl|spacing|spread|sqrt|storage_size|sum|system_clock|tan|tanh|this_image|tiny|trailz|transfer|transpose|trim|ubound|ucobound|unpack|verify)
  firstOnLine: '^\s*'
  parenthesisStart: '\(\s*'
  parenthesisEnd: '\s*\)'

contexts:
  main:
    - include: comments 
    - include: types
    - include: attribute
    - include: operators
    - include: control
    - include: strings
    - include: continuation
    - include: procedures
    - include: modules
    - include: classdefinitions
    - include: separators
    - include: numbers
    - include: constants

  comments:
    - match: "!"
      scope: punctuation.definition.comment
      push:
      - meta_scope: comment.line
      - match: \n 
        pop: true

  types:
    - match: '{{firstOnLine}}\b{{intrinsicType}}\b'
      scope: storage.type
      push: declaration
    - match: '\b(type|class){{parenthesisStart}}\s*(\w*){{parenthesisEnd}}'
      captures:
        1: storage.type.class
        2: entity.name.class
      push: declaration

  attribute:
    - match: '\b{{intrinsicAttribute}}\b'
      scope: storage.modifier

  operators:
    - match: (==|/=|>=|<=|<|>)
      scope: keyword.operator.logical
    - match: (\.and\.|\.or\.|\.ne\.|\.lt\.|\.le\.|\.gt\.|\.ge\.|\.eq\.|\.not\.)
      scope: keyword.operator.word
    - match: (=>)
      scope: keyword.operator
    - match: (\*|\+|-|/|=)
      scope: keyword.operator.arithmetic

  separators:
    - match: '(::)'
      scope: keyword.separator

  control:
    - include: comments
    # if ()
    - match: '{{firstOnLine}}(if)\s*{{parenthesisStart}}'
      captures:
        1: keyword.control.conditional
      push: condition-parser
    # then
    - match: '\b(then)\b'
      scope: keyword.control.conditional
    # elseif ()
    - match: '{{firstOnLine}}(else)\s*(if)'
      captures:
        1: keyword.control.conditional
        2: keyword.control.conditional
    # else
    - match: '{{firstOnLine}}*(else)\b'
      scope: keyword.control.conditional
    # endif
    - match: '{{firstOnLine}}(end\s*if)\b'
      captures:
        1: keyword.control.conditional
    # do 
    - match: '{{firstOnLine}}(do)'
      captures:
        1: keyword.control.conditional
      push: do-loop
    # enddo
    - match: '{{firstOnLine}}(end\s*do)\b'
      captures:
        1: keyword.control

  do-loop:
    - match: '(while)\s*{{parenthesisStart}}'
      captures:
        1: keyword.control
      set: condition-parser

  condition-parser:
    - include: operators
    - include: numbers
    - match: '{{parenthesisEnd}}'
      pop: true

  newline-pop:
    - match: '\n'
      pop: true     

  declaration:
    - include: attribute
    - include: operators
    - include: separators
    - match: '\b(in|out|inout)\b'
      scope: keyword.other
    - match: '\n'
      pop: true

  continuation:
    - match: "&"
      scope: punctuation.separator.continuation

  strings:
    - match: "//"
      scope: keyword.operator.arithmetic
    - match: "'"
      push: string.single 
    - match: '"'
      push: string.double

  string.single:
    - meta_scope: string.quoted.single
    - include: string.continuation
    - include: newline-pop
    - match: "'"
      pop: true

  string.double:
    - meta_scope: string.quoted.single
    - include: string.continuation
    - include: newline-pop 
    - match: '"'
      pop: true

  string.continuation:
    - match: "&"
      scope: punctuation.separator.continuation
      push: 
        # locate continuation on next line and pop
        - match: "&" 
          scope: punctuation.separator.continuation 
          pop: true 

  procedures:
    - match: \b({{intrinsicFunction}})\(
      captures: 
        1: variable.function
      push: argument.parser

    - match: \s*(result)\s*\( 
      captures: 
        1: keyword.control
      push: argument.parser

    - match: \b(pure)\b
      scope: storage.modifier

    - match: (implicit none)
      scope: keyword.control

    - match: (end)
      scope: keyword.control

    - match: (module|)\s*\b(function|subroutine)\b\s*(\w*)(\(|)
      captures:
        1: storage.modifier
        2: keyword.declaration.function
        3: entity.name.function 
      push: argument.parser   

    - match: '{{firstOnLine}}(call)'
      captures:
        1: keyword.control 
      push: function-parser 

  function-parser:
    - match: '\s*(\w*)\('
      captures:
        1: variable.function
      set: argument.parser

  argument.parser:
    - include: operators
    - include: comments
    - include: strings
    - match: (\w*)
      captures: 
        1: variable.other
    - match: ","
      scope: punctuation.separator
    - match: "&"
      scope: punctuation.separator.continuation
      push: argument.parser
    - match: \n
      pop: true
    - match: \)
      pop: true

  modules:
    - match: '\b(module)\b\s*(\w*)$'
      captures: 
        1: keyword.declaration.interface
        2: entity.name.interface
    - match: \b(submodule)\b\s*\((\w*)\)\s*(\w*)
      captures:
        1: keyword.declaration.interface
        2: entity.name.interface
        3: entity.name.interface
    - match: \b(submodule)\b\s*(\w*)
      captures:
        1: keyword.declaration.interface
        2: entity.name.interface

  classdefinitions:
    - match: '\b(type)(?!{{parenthesisStart}})'
      scope: storage.type.class
      push: class.name
    - match: (procedure)
      scope: keyword.declaration.interface
    - match: (contains)
      scope: keyword.declaration.interface

  class.name:
    - include: newline-pop
    - match: '\b(extends)\b{{parenthesisStart}}(\w*){{parenthesisEnd}}'
      captures:
        1: keyword.operator
        2: entity.other.inherited-class
    - match: '\b(abstract)\b'
      scope: storage.modifier
    - match: '(::)\s*(\w*)'
      captures:
        1: keyword.separator
        2: entity.name.class
    - match: '(?<=[end\s*type])(\w*)'
      scope: entity.name.class

  numbers:
    - match: '\b(\d+[\.]?[\d+]?[d]?[\+|\-]?\d*)'
      captures: 
        1: constant.numeric

  constants:
    - match: (\.true\.|\.false\.)
      scope: constant.language
